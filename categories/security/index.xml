<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on 0x74696d</title>
    <link>http://0x74696d.com/categories/security/index.xml</link>
    <description>Recent content in Security on 0x74696d</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://0x74696d.com/categories/security/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Session Store Design</title>
      <link>http://0x74696d.com/posts/session-store-design/</link>
      <pubDate>Wed, 17 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>http://0x74696d.com/posts/session-store-design/</guid>
      <description>

&lt;p&gt;After my talk on DynamoDB a few weeks ago, one of the guys from Basho sent me an email and told me I should check out Riak. So in order to have a project to mess around with it, I decided to work up a session store for Flask. Session stores are one of the use cases called out on Basho&#39;s site, so I figured that&#39;d be a good experiment. I&#39;ll talk about that project in a later post. Today I want to talk about the session design and about data stores for sessions.&lt;/p&gt;

&lt;p&gt;Sessions are an attempt to solve one of the problems around keeping user-associated state in web applications. Because sessions often are used to authenticate users between requests or maintain workflow state, they&#39;re a security-sensitive portion of the application better left to framework developers. But most frameworks give you some options and you should understand the tradeoffs. In broad strokes, these options can be divided into client-side and server-side.&lt;/p&gt;

&lt;h2 id=&#34;client-side-sessions&#34;&gt;Client-side Sessions&lt;/h2&gt;

&lt;p&gt;Client-side sessions leave no state behind on the server and instead put session data into a cookie that is transmitted back and forth between the browser (or other client) and the server. I like to think of this as having the state stored &amp;quot;on the wire.&amp;quot; The workflow looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130717/client-side-sessions.png&#34; alt=&#34;client-side sessions workflow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note that the session has been signed using HMAC to detect tampering. Order of operations is important here. The application framework has to check the HMAC &lt;em&gt;before&lt;/em&gt; decoding and deserializing the cookie value. Otherwise you&#39;re potentially deserializing user-provided data, which I hopefully don&#39;t have to tell you is potentially a Very Bad Thing.&lt;/p&gt;

&lt;p&gt;Also note that we have the option of encrypting the value of the cookie server-side before encoding it. If you don&#39;t, then the session data can be trivially read client-side. Of course, this might be what you want for your application, but you should be aware of it. You can encrypt after serialization to make the cookie entirely unreadable to the client or encrypt selected values in your data structure before serializing it if you want to have a mix of client-readable and non-client-readable data.&lt;/p&gt;

&lt;p&gt;The size of stored session data is a potential gotcha. &lt;a href=&#34;http://www.ietf.org/rfc/rfc2965.txt&#34;&gt;RFC #2965&lt;/a&gt; says that implementations should not limit cookie sizes, but in practice browsers and web servers do. From what I can find browsers typically limit to 4093 bytes per domain. Web servers have their own limits that can be individually configured; on Nginx this limit includes the entire client header (see &lt;a href=&#34;http://wiki.nginx.org/HttpCoreModule#large_client_header_buffers&#34;&gt;large_client_header_buffers&lt;/a&gt; in the Nginx docs). Remember to include the size of your HMAC signature and delimiter in the cookie size -- that&#39;s going to be 40 bytes for a SHA-1 and 64 bytes for a SHA-256 signature. I suggest not trying to cut it close on the cookie size.&lt;/p&gt;

&lt;p&gt;One of the major advantages of this approach, and why &lt;a href=&#34;http://www.dramafever.com&#34;&gt;we&lt;/a&gt; use it is because it doesn&#39;t require database writes. If you&#39;re frequently updating session data and that data isn&#39;t sensitive, this might be a good approach.&lt;/p&gt;

&lt;p&gt;Several of the popular Python web frameworks give you this option. Flask is currently shipping with the &lt;code&gt;itsdangerous&lt;/code&gt; plugin. You can turn on cookie-backed sessions in Django by setting &lt;code&gt;SESSION_ENGINE = &amp;quot;django.contrib.sessions.backends.signed_cookies&amp;quot;&lt;/code&gt;. I hear Pylons ships with &lt;code&gt;beaker&lt;/code&gt; (I haven&#39;t looked at this in detail, so I don&#39;t know how good it is). If you&#39;re looking at some other framework&#39;s options, you want to make sure the author is signing the cookie with HMAC and not some other half-assed hash mechanism. Make sure the secret key you use for signing isn&#39;t accessible by anyone other than your web process -- hardening keys for web apps is worth a post all on its own.&lt;/p&gt;

&lt;p&gt;Other than session data size and letting the client read unencrypted session data, another potential problem with client-side sessions is that they&#39;re racy. Suppose your application has several Ajax calls on a single web page. Ajax call #1 is fired, then Ajax call #2 is fired. But variable latency means that call #2 returns first, and let&#39;s further suppose the session has been modified. When call #1 returns immediately thereafter, it overwrites the session values set in call #2. For many applications this isn&#39;t going to be a deal-breaker; if you don&#39;t make async calls that modify the cookie you have nothing to worry about.&lt;/p&gt;

&lt;h2 id=&#34;server-side-sessions&#34;&gt;Server-side Sessions&lt;/h2&gt;

&lt;p&gt;If you want to store large chunks of data or don&#39;t want to encrypt session data, you&#39;ll want to use server-side sessions. This means we pass the client a cookie with a session identifier and then use that ID to lookup the session data from some kind of data store. This workflow is less complex and looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130717/server-side-sessions.png&#34; alt=&#34;server-side sessions workflow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Server side sessions are easier to get right from a security perspective. As long as you have a hard-to-spoof session token you&#39;re in pretty good shape (but see the notes about HTTP-only and SSL below). If you want to go crazy, you can finger-print the client and then use that and your secret key to sign the session token to reduce the risk of session stealing. In practice if you do that you&#39;ll end up logging people out and losing sessions more often than you might intend -- browser fingerprints change a lot.&lt;/p&gt;

&lt;p&gt;The backing datastore for your sessions can be just about anything, but you&#39;ll want to select one based on your needs for latency, availability, and consistency. Low-latency is fairly critical as you get more users. If you&#39;re building something like a startup with an intent for explosive growth, keep in mind that if you&#39;re using something like MySQL that the table is going to be appended-to frequently and have a lot of updates. (Your product designers are going to want to stick all kinds of data in the session.) This is going to impact latency to a point where availability might be compromised. Redis is popular for sessions because it combines high speed -- everything is in RAM -- with the ability to shard easily and back it off to disk for persistence. If you don&#39;t care about persistence at all, memcached can work.&lt;/p&gt;

&lt;p&gt;The mini-project I discussed in the intro uses Riak as a session store for Flask so that I can compare it against using DynamoDB and play around with its cool operations tools. The problem both of these stores have is lack of consistency; this might not be a problem for a given application but if it isn&#39;t one might want to go with client-side sessions anyways. You can tune Riak to be more consistent by manipulating the &lt;code&gt;r&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt; variables, but naturally this is going to reduce availability. (I suspect but haven&#39;t confirmed that it will increase latency slightly as well.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;aside&gt;Addendum 2013/10/12: &lt;a href =&#34;https://twitter.com/hectcastro/statuses/357834726419087360&#34;&gt;Hector Castro&lt;/a&gt; from Basho says tht bumping up R/W consistency does have an effect on latency and that you should check out &lt;a href=&#34;http://basho.com/riaks-config-behaviors-part-2/&#34;&gt;this doc&lt;/a&gt; for more details.&lt;/aside&gt;
&lt;/blockquote&gt;

&lt;p&gt;Most of the popular Python web frameworks give you the option for server-side sessions too. In Django it&#39;s the default session engine. CherryPy gives only this option. For Flask you&#39;ll need to write your own or select one already written like &lt;a href=&#34;http://flask.pocoo.org/snippets/75/&#34;&gt;this one&lt;/a&gt; for Redis-backed sessions that I used as inspiration for the &lt;code&gt;flask-riak-sessions&lt;/code&gt; project I&#39;m working on. Note that snippet uses &lt;code&gt;pickle&lt;/code&gt;, which I don&#39;t recommend as a serializer for sessions because I&#39;m paranoid. It&#39;s too easy to screw up and put unsanitized data into the session store and have it deserialized into arbitrary Python code that will pwn your server.&lt;/p&gt;

&lt;h2 id=&#34;securing-sessions-on-the-wire&#34;&gt;Securing Sessions on the Wire&lt;/h2&gt;

&lt;p&gt;Both server-side and client-side sessions use cookies to maintain state. If a cookie is spoofed, the attacker can act as if he were the legitimate client. There are a couple of mechanisms you as an application designer can use to harden cookies during transmission -- but if the user&#39;s browser is compromised then all bets are off.&lt;/p&gt;

&lt;p&gt;First is to set the &lt;a href=&#34;http://tools.ietf.org/html/rfc6265#section-5.2.6&#34;&gt;HttpOnly&lt;/a&gt; flag at the server. If you do a search on this flag, there&#39;s a pretty good chance you&#39;re going to end up at &lt;a href=&#34;http://stackoverflow.com/questions/27972/how-do-httponly-cookies-work-with-ajax-requests&#34;&gt;this&lt;/a&gt; StackOverflow discussion which has some dated information so beware. The purpose of HttpOnly is to prevent client-side scripts from manipulating cookies. Cookies set by the server are still returned by Ajax calls from the client, so you can use HttpOnly cookies for authenticated Ajax APIs for server-side sessions. If you intend for the client to access the cookie then you don&#39;t want to set HttpOnly.&lt;/p&gt;

&lt;p&gt;The other protection is to use SSL for authenticated sessions, and not just during login. This prevents sniffing the cookie in transit. There&#39;s an obvious cost impact for having everything under SSL; if you&#39;re using a CDN in front of your application this cost can be quite high.&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h2&gt;

&lt;p&gt;There isn&#39;t really a don&#39;t-make-me-think-version of this post. You should almost certainly be using the HttpOnly flag and putting your whole site under SSL for authenticated users. If you have any question as to whether you will be putting sensitive data in the session or how to encrypt that data safely, you should be using a server-backed session. Redis is a great backing store for server-backed sessions. Client-side sessions have their place, but there are plenty of fairly bad client-side session implementations out there so do your research.&lt;/p&gt;

&lt;blockquote&gt;
&lt;aside&gt;Thanks to &lt;a href=&#34;https://github.com/JohnRomanski&#34;&gt;John Romanski&lt;/a&gt; who was kind enough to review this post for technical errors and style advice.&lt;/aside&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Securing Charles Proxy with a Personal CA</title>
      <link>http://0x74696d.com/posts/charlesssl/</link>
      <pubDate>Mon, 13 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://0x74696d.com/posts/charlesssl/</guid>
      <description>&lt;p&gt;Some of the guys in my shop like to use &lt;a href=&#34;http://www.charlesproxy.com&#34;&gt;Charles&lt;/a&gt; proxy to help debug their web and mobile applications. It&#39;s no good for non-HTTP traffic so it&#39;s a bit of a unitasker, but modulo some questionable UI choices it&#39;s not bad.  Charles is user-friendly enough that you can hand it off to a wet-behind-the-ears web developer who wouldn&#39;t know a TCP SYN flag if you waved it at him.  And it has some nice features like on-the-fly traffic throttling that we find handy in the online video business -- as far as I know you can&#39;t do that with &lt;a href=&#34;http://portswigger.net/burp/&#34;&gt;Burp suite&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But Charles has one head-scratcher, and that&#39;s proxying SSL traffic.  The author gives instructions to &lt;a href=&#34;http://www.charlesproxy.com/documentation/using-charles/ssl-certificates/&#34;&gt;install the Charles certificate&lt;/a&gt; as a trusted root, but this is a &lt;em&gt;really&lt;/em&gt; bad idea.  Anyone can download that certificate and key and use it to sign certificates in the same way Charles does.  Which means if you set the Charles certificate as trusted root, you&#39;re one DNS spoof or spearphishing attack away from handing over your credentials to arbitrary secure sites to the owner of some sketchy &lt;code&gt;.ru&lt;/code&gt; domain.&lt;/p&gt;

&lt;p&gt;What you &lt;em&gt;should&lt;/em&gt; do (and what the &lt;a href=&#34;http://blog.xk72.com/&#34;&gt;author&lt;/a&gt; of Charles should recommend) is to set up your own certificate authority (CA) and trust that instead.  We can use this for more than just Charles, but I&#39;ll touch on that at the end of this post.  The whole process is barely more complicated than generating the X.509 self-signed cert you might be using for your home web server anyways.  The instructions below work on my OS X development machine but should be the same for any Unixy machine with OpenSSL installed.&lt;/p&gt;

&lt;p&gt;We&#39;re going to build our new CA in &lt;code&gt;/usr/local&lt;/code&gt;, and OpenSSL on my machine was built so that its configuration file was stored in &lt;code&gt;/opt/local/etc/openssl/openssl.cnf&lt;/code&gt;.  Yeah, yeah, we can get religious about the Unix FHS some other time.  Let&#39;s get our environment prepped:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /usr/local/CharlesCA
cd /usr/local/CharlesCA
mkdir certs private newcerts
echo 01 &amp;gt; serial
touch index.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the last two items: &lt;code&gt;serial&lt;/code&gt; contains the next serial number that will be assigned to a cert, in hex.  The &lt;code&gt;index.txt&lt;/code&gt; file is the text database of issued certificates.  Next we create the certificate and key used for our new CA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl req -new -x509 -days 3650 -extensions v3_ca \
            -keyout private/ca_key.pem -out certs/ca_cert.pem \
            -config /opt/local/etc/openssl/openssl.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, what are we doing here?  We&#39;re making a new X.509 certificate request with the appropriate extension to use the certificate for signing other certificates (or in other words, use it as a CA).  We&#39;re going to give it a very long expiration period because we&#39;re lazy and want to guarantee we won&#39;t have to do this again on this machine.  And we&#39;re outputting both a private keyfile (&lt;code&gt;ca_key.pem&lt;/code&gt;) and the public certificate file (&lt;code&gt;ca_cert.pem&lt;/code&gt;). If you&#39;re following along, you&#39;ll get something like the below.  Fill in your information.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Generating a 1024 bit RSA private key
...++++++
........................................++++++
writing new private key to private/ca_key.pem
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be
incorporated into your certificate request.
What you are about to enter is what is called a Distinguished Name
or a DN. There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter ., the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Pennsylvania
Locality Name (eg, city) []:Philadelphia
Organization Name (eg, company) [Internet Widgets Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:0x74696d.com
Email Address []:tim@0x74696d.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ve got our CA now, and if we trust it as a root authority (we&#39;ll get to that in a minute), we can create SSL certificates that our browser will accept without complaint.  But Charles expects the signing certificate to be in PKCS12 format.  So we need to use OpenSSL again to convert our keys to a .pfx file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl pkcs12 -export -out ca_cert.pfx -inkey private/ca_key.pem \
               -in certs/ca_cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;aside&gt;Update 2013/10/12: Thanks to &lt;a href=&#34;https://twitter.com/markaufflick&#34;&gt;Mark Aufflick&lt;/a&gt; who pointed out I was missing the certs directory path from the &#34;-in&#34; argument of this command&lt;/aside&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;ca_cert.pfx&lt;/code&gt; output file for this is what we&#39;ll add as a trusted root cert.  On OS X the easiest way to do this is just to hit the directory in Finder and double-click the cert (you can also use the &lt;code&gt;security&lt;/code&gt; command-line interface).  Keychain Access will come up and ask you if you&#39;re really really sure, that you&#39;re aware that you are granting this cert the right to make arbitrary Facebook posts about your mother-in-law on your behalf, etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130513/1.png&#34; alt=&#34;Do you want to trust certificates signed by 0x74696d.com?&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You should see the following when you&#39;re done.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130513/2.png&#34; alt=&#34;This certificate is marked as trusted&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now we can fire up Charles and configure it to use our new certificate.  Under Proxy Settings and the SSL tab, check &lt;em&gt;Use a Custom CA Certificate&lt;/em&gt;.  For some reason on my installation, the Choose button would not find &lt;code&gt;/usr/local&lt;/code&gt; at all so I had to enter the path by hand.  We&#39;ll trust this for all locations.&lt;/p&gt;

&lt;blockquote&gt;
&lt;aside&gt;Update 2013/10/12: Thanks to &lt;a href=&#34;https://twitter.com/markaufflick&#34;&gt;Mark Aufflick&lt;/a&gt; who pointed out you can just drag the .pfx file into the dialog.&lt;/aside&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130513/3.png&#34; alt=&#34;Proxy settings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And now we can go visit our favorite SSL-secured sites and sniff the exchange.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://0x74696d.com/images/20130513/4.png&#34; alt=&#34;Sniffing Github traffic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can use this same CA to sign what would otherwise be snake-oil certs for your development environment so that you don&#39;t have to shell out for an SSL certificate. But I like to use a separate CA for that -- each machine I use for development can have its own CA generating temporary certs like those used by Charles, and I can have a separate one for signing certificates I want to use across multiple machines. This also makes revocation easier if you lose a machine to theft.&lt;/p&gt;

&lt;p&gt;The machine with the private key for that CA is an internally-facing server and not something like a laptop that you&#39;ll carry into high-risk environments like an open WiFi at LAS during DEFCON.  Or ideally, you should remove the CA entirely from your machine once you&#39;ve created certificates with it, and leave the private key burned to a CD so you can recreate the CA and renew the certificates when necessary. This way the key can&#39;t be compromised without the theft of the CD backup.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>